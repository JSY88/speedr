<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>빠른 읽기 훈련</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        input[type="range"], input[type="number"], select, input[type="color"] {
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        input[type="range"] {
            flex: 1;
            min-width: 120px;
        }

        input[type="number"] {
            width: 80px;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }

        select {
            min-width: 120px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff7b7b 0%, #ff6b6b 100%);
            color: white;
        }

        .btn-tertiary {
            background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .reading-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            text-align: center;
            position: relative;
        }

        .reading-area.focus-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            border-radius: 0;
            margin: 0;
        }

        .current-char {
            font-size: 4rem;
            font-weight: 700;
            line-height: 1;
            transition: all 0.1s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-all;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .progress-info {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .progress-bar {
            width: 100%;
            max-width: 400px;
            height: 8px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: #666;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-weight: 700;
            font-size: 1.1rem;
            color: #333;
        }

        .focus-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .reading-area.focus-mode .focus-hint {
            opacity: 1;
        }

        .focus-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .reading-area.show-controls .focus-controls {
            opacity: 1;
        }

        .focus-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            min-width: 80px;
        }

        .focus-btn-primary {
            background: rgba(76, 175, 80, 0.9);
        }

        .focus-btn-secondary {
            background: rgba(255, 123, 123, 0.9);
        }

        .focus-btn-tertiary {
            background: rgba(255, 167, 38, 0.9);
        }

        .focus-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .timer-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .reading-area.focus-mode .timer-display {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .controls {
                padding: 20px;
            }

            .current-char {
                font-size: 3rem;
                min-height: 60px;
            }

            .reading-area {
                padding: 20px;
                min-height: 250px;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .control-row > * {
                width: 100%;
            }

            .buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .focus-controls {
                bottom: 20px;
                gap: 10px;
            }

            .focus-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
                min-width: 70px;
            }

            .timer-display {
                top: 15px;
                left: 15px;
                font-size: 0.9rem;
                padding: 6px 12px;
            }

            .focus-hint {
                top: 15px;
                right: 15px;
                font-size: 0.75rem;
                padding: 6px 10px;
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚡ 빠른 읽기 훈련</h1>
            <p>글자 단위 빠른 읽기로 기분과 집중력을 향상시켜보세요</p>
            <p style="font-size: 0.75rem; margin-top: 5px; opacity: 0.7;">💾 설정 자동 저장 | ⚠️ 라이브러리는 세션 동안만 유지 (실제 환경에서 영구 저장 가능)</p>
        </div>

        <div class="controls" id="controls">
            <div class="control-group">
                <label>📚 텍스트 라이브러리</label>
                <div class="control-row">
                    <select id="librarySelect" style="flex: 1;">
                        <option value="">라이브러리에서 선택...</option>
                    </select>
                    <button type="button" onclick="loadFromLibrary()" style="padding: 8px 15px; border: 2px solid #e1e8ed; border-radius: 10px; background: #f8f9fa; cursor: pointer; font-size: 0.9rem;">불러오기</button>
                    <button type="button" onclick="deleteFromLibrary()" style="padding: 8px 15px; border: 2px solid #ff6b6b; border-radius: 10px; background: #ffe0e0; color: #ff6b6b; cursor: pointer; font-size: 0.9rem;">삭제</button>
                </div>
                
                <!-- 새 텍스트 추가 섹션 -->
                <div style="margin-top: 15px; padding: 15px; background: rgba(102, 126, 234, 0.05); border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.2);">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 0.9rem;">📝 새 텍스트 추가</label>
                    <input type="text" id="newLibraryName" placeholder="텍스트 이름" style="width: 100%; padding: 8px 12px; border: 2px solid #e1e8ed; border-radius: 10px; font-size: 0.9rem; margin-bottom: 8px;">
                    <textarea id="newLibraryText" placeholder="여기에 텍스트를 입력하세요..." style="width: 100%; height: 100px; padding: 8px 12px; border: 2px solid #e1e8ed; border-radius: 10px; font-size: 0.9rem; resize: vertical; font-family: inherit; margin-bottom: 8px;"></textarea>
                    <div class="control-row">
                        <button type="button" onclick="addTextToLibrary()" style="flex: 1; padding: 10px; border: none; border-radius: 10px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; cursor: pointer; font-size: 0.9rem; font-weight: 600;">라이브러리에 추가</button>
                        <button type="button" onclick="addCurrentToLibrary()" style="flex: 1; padding: 10px; border: none; border-radius: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; cursor: pointer; font-size: 0.9rem; font-weight: 600; margin-left: 8px;">현재 텍스트 추가</button>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>🎲 재생 모드</label>
                <div class="control-row">
                    <select id="playbackMode">
                        <option value="repeat">반복 재생</option>
                        <option value="random">랜덤 재생</option>
                    </select>
                </div>
                <div style="margin-top: 5px; font-size: 0.75rem; color: #666;">
                    랜덤 모드: 텍스트가 끝나면 라이브러리에서 다른 텍스트를 자동 선택
                </div>
            </div>

            <div class="control-group">
                <label>📄 텍스트 파일 선택</label>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".txt">
                    <label for="fileInput" class="file-input-label">텍스트 파일 선택 (.txt)</label>
                </div>
            </div>

            <div class="control-group">
                <label>⚡ 속도 설정 (밀리초)</label>
                <div class="control-row">
                    <input type="range" id="startSpeed" min="40" max="500" value="200">
                    <input type="number" id="startSpeedNum" min="40" max="500" value="200">
                    <span>→</span>
                    <input type="range" id="endSpeed" min="40" max="500" value="40">
                    <input type="number" id="endSpeedNum" min="40" max="500" value="40">
                </div>
                <div style="margin-top: 10px;">
                    <label style="margin-bottom: 5px;">점진적 변화 시간 (초)</label>
                    <div class="control-row">
                        <input type="range" id="transitionDuration" min="0" max="60" value="10">
                        <input type="number" id="transitionDurationNum" min="0" max="60" value="10">
                    </div>
                    <div style="margin-top: 5px; font-size: 0.75rem; color: #666; line-height: 1.3;">
                        <strong>0초</strong>: 처음부터 끝까지 고정 속도 (시작 속도로만 진행)<br>
                        <strong>10초</strong>: 훈련 시작 후 정확히 10초 동안 시작→끝 속도로 변화<br>
                        <strong>30초 이상</strong>: 30초 후 최고 속도 도달, 이후 계속 유지 (텍스트 반복시에도 유지)
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>🎨 디스플레이 설정</label>
                <div class="control-row">
                    <select id="fontFamily">
                        <option value="'Noto Sans KR', Arial, sans-serif">Noto Sans KR</option>
                        <option value="'Malgun Gothic', sans-serif">맑은 고딕</option>
                        <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
                        <option value="monospace">Monospace</option>
                    </select>
                    <input type="range" id="fontSize" min="20" max="900" value="40" step="10">
                    <input type="number" id="fontSizeNum" min="20" max="900" value="40" step="10">
                    <span>px</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <input type="color" id="textColor" value="#333333">
                    <span>텍스트</span>
                    <input type="color" id="bgColor" value="#ffffff">
                    <span>배경</span>
                </div>
                <div style="margin-top: 5px; font-size: 0.75rem; color: #666;">
                    큰 폰트 크기(300px+)는 몰입도 향상에 도움이 되지만, 화면 크기를 고려하세요
                </div>
            </div>

            <div class="control-group">
                <label>📖 읽기 모드</label>
                <div class="control-row">
                    <select id="readingMode">
                        <option value="char">글자 단위</option>
                        <option value="word">단어 단위</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label>⏰ 훈련 시간 설정</label>
                <div class="control-row">
                    <input type="number" id="timerMinutes" min="0" max="60" value="5" style="width: 80px;">
                    <span>분</span>
                    <input type="number" id="timerSeconds" min="0" max="59" value="0" style="width: 80px;">
                    <span>초</span>
                    <span style="font-size: 0.8rem; color: #666;">(0분 0초 = 무제한)</span>
                </div>
            </div>

            <div class="buttons">
                <button class="btn btn-primary" onclick="startReading()" id="startBtn">▶️ 시작</button>
                <button class="btn btn-secondary" onclick="pauseReading()" id="pauseBtn" disabled>⏸️ 일시정지</button>
                <button class="btn btn-tertiary" onclick="stopReading()" id="stopBtn" disabled>⏹️ 정지</button>
            </div>
        </div>

        <div class="reading-area" id="readingArea" onclick="toggleFocusMode()">
            <div class="focus-hint">화면을 터치하면 집중 모드가 해제됩니다</div>
            <div class="timer-display" id="timerDisplay">05:00</div>
            <div class="current-char" id="currentChar">텍스트를 선택하고 시작 버튼을 눌러주세요</div>
            <div class="focus-controls" id="focusControls">
                <button class="focus-btn focus-btn-primary" onclick="event.stopPropagation(); resumeReading()" id="focusResumeBtn">▶️ 재개</button>
                <button class="focus-btn focus-btn-secondary" onclick="event.stopPropagation(); pauseReading()" id="focusPauseBtn">⏸️ 일시정지</button>
                <button class="focus-btn focus-btn-tertiary" onclick="event.stopPropagation(); stopReading()" id="focusStopBtn">⏹️ 정지</button>
            </div>
            <div class="progress-info">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="progressText">0%</div>
                        <div id="progressLabel">진행률</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="currentSpeed">200</div>
                        <div>현재 속도 (ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="elapsed">00:00</div>
                        <div>경과 시간</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let text = '';
        let processedText = '';
        let currentIndex = 0;
        let isReading = false;
        let isPaused = false;
        let startTime = 0;
        let currentTimeout;
        let focusTimeout;
        let isFocusMode = false;
        let timerInterval;
        let totalTimerMs = 0;
        let remainingTimerMs = 0;
        let textRepeatCount = 0;
        let lastUpdateTime = 0;
        let frameRequestId = null;
        let targetSpeed = 200;
        let nextScheduledTime = 0;
        let textLibrary = [
            {
                name: '샘플 텍스트 - 빠른 읽기 소개',
                content: '바다파도서핑보드나무숲곰꿀벌노란색해바라기반고흐귀소라껍데기소음조용함명상연꽃연못개구리점프트램펄린공중비행기구름솜베개잠꿈무지개색깔팔레트화가붓털고양이야옹밤올빼미지혜책종이나비변신마법지팡이나무뿌리땅지렁이비우산그림자해시계시간시계톱니바퀴기계로봇미래우주별소원유성속도경주말당근토끼귀듣기음악피아노건반흑백체스왕왕관보석다이아몬드반짝임눈겨울눈사람코당근주황색호박할로윈유령하얀색구름양털실스웨터따뜻함포옹사랑하트심장박동리듬춤발레백조호수거울반사빛프리즘삼각형피라미드이집트사막낙타혹산등반밧줄매듭선원항해나침반북극펭귄턱시도정장넥타이매듭실바늘가시장미빨간색사과과수원나무사다리높이새날개자유바람연실거미거미줄덫사냥활화살과녁정확함시계정시기차철도선로평행선수학숫자0원바퀴자전거페달발신발끈묶기선물리본나비꽃향기코코끼리기억앨범사진순간찰나번개천둥소리메아리산골짜기강흐름시간모래시계모래해변조개진주목걸이목기린높이하늘파란색바다물고기비늘반짝임은색달밤불빛촛불왁스밀랍봉인편지우체통빨간색장미가시아픔치료약쓴맛커피원두갈색초콜릿달콤함꿀벌집육각형벌윙윙소음헤드폰음악노래새지저귐아침해노란색레몬신맛찡그림표정거울유리투명함공기바람태풍회전팽이장난감어린이웃음기쁨눈물짠맛바다소금하얀색눈스키미끄러짐얼음차가움냉장고음식요리불성냥작은개미줄행진군대제복초록색잎나무그늘시원함에어컨바람선풍기날개천사하늘구름양목장풀젖소우유하얀색눈눈사람당근코냄새향수병유리깨짐조각퍼즐맞추기열쇠자물쇠문손잡이손악수만남인사모자머리생각전구아이디어발명과학자실험실험실하얀색가운의사청진기심장사랑편지우표여행여행가방바퀴굴리기공축구잔디초록색숲나무그네어린시절추억앨범책이야기상상구름모양동물사자갈기털따뜻함담요잠베개깃털새하늘무한우주별자리연결점선그림미술붓물감색깔무지개비우산보호지붕집가족식탁음식포크길갈래선택결정동전던지기확률수학계산기버튼누르기벨소리파동바다서핑균형줄타기서커스광대빨간코웃음재미놀이공원롤러코스터속도바람머리카락날리기깃발나라지구둥글음공농구높이점프개구리연못물투명함유리창보기눈속눈썹깜빡임신호교통신호빨간불정지멈춤쉼표문장단어글자알파벳A1등우승트로피금색해태양에너지전기번개지그재그뱀긴기차칙칙폭폭소리음성목소리노래가수무대조명밝음전구둥글음원동그라미0숫자계산수학문제해결열쇠금고비밀속삭임바람나뭇잎흔들림춤무용수발끝뾰족함바늘주사의사병원하얀색천사날개깃털가벼움공기풍선터짐놀람깜짝상자선물포장지반짝임별밤하늘어둠손전등빛길방향화살표활궁수과녁중심배꼽웃음간지럼깃털닭달걀노란색해바라기씨앗심기정원꽃향기벌꿀달콤함설탕하얀색소금짠맛눈물슬픔비구름회색코끼리코길음코뿔소뿔뾰족함연필쓰기손다섯별소원간절함기도교회종소리울림동심원물결바다끝없음무한우주신비마법지팡이막대직선자측정길이거리멀리여행모험탐험가나침반방향동서남북십자병원적십자도움손악수친구우정반지결혼사랑하트빨간색딸기달콤함미소입술키스사랑편지하트모양구름하늘파란색바다나무뿌리땅속지렁이움직임춤발레백조호수거울반사빛프리즘무지개색깔팔레트화가붓털고양이야옹밤달치즈쥐작은개미힘운동땀짠맛바다파도서핑보드스케이트얼음차가움겨울눈사람당근코냄새향수장미가시아픔눈물소금하얀색천사날개하늘구름양털실스웨터따뜻함포옹사랑하트빨간색사과과수원농장닭달걀노란색해바라기씨앗심기정원꽃벌꿀달콤함설탕커피원두갈색초콜릿카카오아프리카사자갈기머리카락샴푸거품비누방울터짐풍선파티케이크촛불불성냥나무종이책이야기상상꿈잠베개깃털새지저귐아침해태양에너지전기번개천둥소리음악피아노건반흑백체스말당근토끼귀듣기비밀속삭임바람연실거미거미줄덫사냥활화살과녁중심배꼽웃음기쁨축제불꽃놀이별소원유성속도자동차바퀴둥글음원0숫자계산수학문제해결열쇠자물쇠문집가족식탁음식포크길방향나침반북극펭귄턱시도정장회사일월요일우울파란색하늘새자유바람머리카락긴기차철도선로직선자측정길이키높이산등반밧줄매듭선원바다물고기비늘반짝임다이아몬드보석반지결혼웨딩드레스하얀색구름솜부드러움아기울음눈물슬픔비우산그림자해시계시간시계톱니바퀴기계로봇미래우주무중력떠다님풍선헬륨가벼움깃털간지럼웃음입치아하얀색우유젖소점박이달마시안개충실함친구우정손악수만남인사모자머리생각전구아이디어발명에디슨전기전선전봇대높이기린목목걸이진주조개바다소라껍데기나선회전팽이장난감어린이순수함맑음물투명함유리창문보기눈속눈썹깜빡임신호교통신호빨간불정지멈춤쉼표문장글작가펜잉크검은색밤올빼미지혜책도서관조용함명상연꽃연못개구리점프트램펄린튀어오름공농구골대높이사다리올라가기계단발걸음신발끈묶기선물리본나비변신애벌레잎초록색나무그늘시원함에어컨바람선풍기날개천사하얀색백지빈공간무선동그라미원완전함만족미소행복웃음소리메아리산골짜기강흐름시간모래시계모래해변조개소리바다깊이심해어둠랜턴불빛나방밤달빛은색거울반사거꾸로뒤집기손바닥손금운명별자리점연결선그림미술붓물감팔레트무지개비구름회색코끼리코길음보폭크기거대함공룡화석돌단단함근육운동헬스장거울모습외모화장립스틱빨간색장미향기코숨쉬기공기산소나무광합성햇빛따뜻함담요잠꿈구름양목장풀잔디축구공둥글음지구행성우주별반짝임다이아몬드보석상자열기비밀보물해적배항해바다수평선직선지름원파이수학계산기버튼누르기벨소리진동떨림지진흔들림나뭇잎바람태풍회전소용돌이물세탁기비누거품목욕따뜻함온도체온계열불용상상동화책종이접기종이비행기날기새하늘파란색바다깊이잠수숨참기인내기다림시간흐름강물돌건너뛰기개구리연못수련꽃꽃잎떨어짐가을단풍빨간색피심장박동리듬음악춤발레리나발끝뾰족함바늘실옷입기옷장문열기열쇠금고돈동전원형바퀴굴리기언덕올라가기힘들음숨가쁨달리기마라톤42.195km숫자암호비밀번호컴퓨터키보드타자소리딱딱나무딱따구리새부리뾰족함화살활무지개다리연결다리건너기강물생명나무산소숨쉬기살아있음움직임춤즐거움축제색깔알록달록앵무새말하기언어단어사전두꺼움책무게킬로그램단위측정자길이미터달리기100미터빠름치타점박이별밤하늘망원경보기관찰과학자실험실험실하얀가운의사청진기듣기귀소라껍데기바다소리파도물결움직임손짓인사안녕만남헤어짐눈물짠맛소금요리맛혀빨간색딸기달콤함꿀벌노란색줄무늬호랑이용감함사자왕왕관금색해밝음전구전기에너지힘근육팔껴안기사랑하트모양그리기크레파스색칠무지개일곱색숫자일곱요일월화수목금토일달력종이나무거울반사빛태양노란색바나나원숭이나무정글탐험모험책도서관조용함교회기도소원별밤올빼미부엉소리메아리산높이하늘새날개깃털가벼움바람연아이놀이터그네흔들림바다파도서핑균형줄타기서커스광대웃음기쁨선물상자네모정사각형수학계산컴퓨터마우스쥐치즈노란색레몬신맛찡그림표정얼굴눈눈물슬픔비우산빨간색딸기잼빵아침커피쓴맛어른일회사넥타이목기린점박이달마시안개꼬리흔들기인사만남악수손다섯손가락피아노음악춤발레백조우아함공주왕관보석다이아몬드반짝임별소원간절함마음하트빨간색사과과일나무그늘시원함여름바다수영물투명함유리창문집가족따뜻함포옹사랑결혼반지원완전함동그라미바퀴자전거페달다리걷기산책공원벤치앉기휴식잠꿈무지개색깔그림붓털고양이야옹밤달은색거울화장예쁨꽃향기벌꿀달콤함설탕하얀색눈겨울추위난로불따뜻함담요잠자리베개부드러움솜구름하늘파란색바다깊이고래큰코끼리코길다기차칙칙폭폭소리시끄러움조용함도서관책종이하얀색백지그림그리기연필나무숲나무잎초록색개구리연못물생명살아있음움직임운동건강의사병원하얀색간호사도움친절미소행복웃음소리음성노래가수무대조명밝음전구둥글음달밤어둠무서움유령하얀색시트침대잠코골이소리진동떨림지진흔들림나뭇가지바람시원함바람개비돌아감회전팽이장난감아이웃음즐거움놀이게임승부이기기1등금메달금색해바라기씨앗작은개미줄행진군대제복초록색나무산소숨쉬기코냄새향수꽃정원가꾸기물주기호스뱀길다머리카락빗질빗이빨하얀색치약민트시원함얼음차가움냉장고음식맛있음요리엄마사랑따뜻함온도체온계열아픔약쓴맛얼굴찡그림우는얼굴눈물물바다소금짠맛프렛즐과자바삭함소리씹기이빨상어무서움도망빨리달리기운동화신발발발가락다섯개손가락반지약속시간시계똑딱소리리듬음악드럼두드리기소리천둥번개빛밝음낮해뜨거움사막낙타혹산등반올라가기계단집문열기열쇠자물쇠잠그기안전경찰도움신고전화벨소리따르릉소리귀듣기음악멜로디아름다움꽃꽃밭나비날개하늘높이새둥지집따뜻함가족함께손잡기연결다리건너기강흐르기시간흘러가기과거추억사진앨범책페이지넘기기바람시원함선풍기바람돌아가기회전목마놀이공원즐거움웃음소리아이들순수함맑음물깨끗함씻기비누거품목욕욕조물따뜻함김올라가기하늘구름회색돌단단함벽그림액자네모사각형창문보기풍경산나무초록색잔디축구공차기발달리기빠름치타빠름바람머리카락날리기깃발나라애국가노래목소리말하기언어외국어공부학교선생님가르치기지식똑똑함부엉이올빼미밤어둠등불불빛따뜻함촛불촛농흘러내리기눈물슬픔위로포옹따뜻함마음사랑빨간색하트모양그리기색연필색깔무지개일곱요일달력날짜생일케이크촛불불어끄기소원별반짝임눈깜빡임윙크귀여움아기작음손작은손귀여움인형장난감놀이재미웃음입하얀이빨우유하얀색종이편지쓰기펜잉크파란색하늘새자유날기비행기여행가방짐무거움들기힘근육운동헬스건강채소초록색상추샐러드건강다이어트살빼기거울보기모습예뻐지기화장립스틱빨간색장미가시아픔찔림피빨간색소방차물끄기불뜨거움여름더위바다시원함파도서핑보드타기균형중심배꼽웃음간지럼깃털새하늘파란색평화조용함명상마음평온호수잔잔함거울같음반사빛반짝임다이아몬드비싸다돈동전동그라미원바퀴굴러가기언덕내려가기빠름스피드자동차빨간색멈춤신호등파란불가기걷기발걸음신발끈묶기나비매듭나비예쁨꽃향기좋은냄새향수병유리투명물깨끗함맑음하늘구름한점없음맑음날씨좋음기분좋음미소웃음하하소리크게확성기소리전달메시지편지우체부빨간모자빨간색토마토빨간색케첩감자튀김노란색바나나원숭이재미있음동물원구경보기눈속눈썹길다기린목높이하늘별밤달밝음등불불빛나방날아오기빛좋아함사랑마음따뜻함봄꽃피어남생명나무자라남키크기높이산올라가기힘들기숨차기헉헉개혀빨간색피생명중요함심장뛰기두근두근소리리듬박자음악악기피아노검은키하얀키체스게임이기기승리기쁨점프높이뛰기하늘가까이별손으로잡기불가능꿈상상생각머리똑똑함공부책읽기안경눈보기거울시계시간흐름강물생명나무뿌리땅지구둥글음공축구잔디초록색개구리점프높이하늘파란색바다깊이고래노래음악피아노건반손가락반지결혼사랑하트빨간색장미가시아픔약쓴맛얼굴찡그림웃음기쁨축제풍선터짐소리귀듣기비밀속삭임바람시원함부채접기종이하얀색눈겨울추위벽난로불따뜻함포옹가족집문열쇠자물쇠안전금고돈동전원형바퀴자전거페달다리걷기발걸음신발끈묶기매듭선원바다파도서핑보드나무숲새지저귐아침해밝음전구전기번개지그재그뱀긴기차철도직선자측정길이키높이산등반밧줄매달리기원숭이바나나노란색해바라기씨앗새부리뾰족함바늘실옷입기따뜻함온도체온계열불성냥작은개미힘들기운동근육팔손악수만남인사모자머리생각아이디어전구둥글음달밤올빼미부엉소리메아리산속나무그늘시원함여름바다물고기비늘반짝임별소원간절함기도교회종소리울림진동떨림무서움유령하얀색구름솜부드러움베개잠꿈무지개색깔크레파스그림붓털고양이야옹밤어둠랜턴불빛나방날개천사하늘높이새자유바람연실거미거미줄끈적함꿀벌노란색줄무늬호랑이용감함사자갈기머리카락긴공주왕관보석다이아몬드빛프리즘무지개일곱색요일달력종이책이야기상상꿈나라잠코골이소리시끄러움조용히도서관책지식똑똑함부엉이밤달빛은색거울반사물투명함유리창문보기풍경산골짜기강흐름시간모래시계모래해변조개소리바다소금짠맛눈물슬픔위로친구우정함께손잡기연결다리건너기용기마음따뜻함사랑빨간색사과맛있음먹기입이빨하얀색우유젖소점박이달마시안개충실함꼬리흔들기기쁨웃음미소행복햇살따뜻함봄꽃향기코냄새향수병유리깨짐조각퍼즐맞추기완성성취감기쁨박수소리박자리듬음악춤발레우아함백조호수잔잔함평화마음편안함휴식의자앉기다리쉬기잠깐시간짧음순간찰나번개빠름치타빠름달리기운동건강의사청진기심장뛰기생명소중함가족사랑따뜻함집보금자리새둥지새알둥글음원완전함만족미소입술빨간색립스틱화장예쁨거울모습외모옷패션멋짐모델워킹걷기산책공원벤치앉기할아버지할머니지혜경험이야기옛날과거추억사진앨범책페이지넘기기바람시원함선풍기돌아가기회전팽이장난감아이웃음순수함맑음하늘구름양털따뜻함스웨터겨울눈사람당근코길음코끼리큰거대함공룡화석돌단단함근육힘무거움들기역도운동땀짠맛바다수영물시원함얼음차가움냉장고음식맛있음요리엄마사랑마음따뜻함햇빛노란색레몬신맛찡그림표정얼굴눈보기관찰과학자실험실험실하얀가운의사도움치료건강운동달리기빠름바람머리카락날리기깃발나라태극기빨간색파란색색깔그림그리기붓물감팔레트화가예술아름다움꽃정원나비날개하늘높이비행기여행가방짐싸기준비계획미래꿈희망별밤하늘망원경보기달밝음등불불빛따뜻함촛불왁스녹기더위여름바다파도소리철썩철썩리듬박자드럼두드리기손박수소리기쁨축하생일케이크촛불소원빌기간절함마음진심정직거짓말안함진실사실현실실제만지기손느끼기감각오감다섯숫자수학계산머리똑똑함공부학교선생님가르치기지식배우기책읽기글자쓰기펜잉크파란색하늘새지저귐소리아름다움음악멜로디노래부르기목소리말하기언어외국어영어ABC알파벳26개숫자많음별셀수없음무한우주넓음광활함바다깊이심해어둠무서움도망빨리달리기운동화신발발10개발가락간지럼웃음즐거움놀이게임재미시간빨리감즐거운시간행복웃음소리하하호호재미있음코미디웃긴광대빨간코빨간색토마토빨갛다익었다맛있다먹고싶다배고픔밥쌀하얀색백미하얀순수깨끗함씻기물깨끗투명유리창문햇빛따뜻함기분좋음미소웃음입꼬리올라감위로하늘높이새자유로움바람시원함바람개비돌기회전원동그라미시계'
            }
        ];
        let lastLoadedText = null;
        let settings = {
            startSpeed: 200,
            endSpeed: 40,
            transitionDuration: 10,
            fontSize: 40,
            fontFamily: "'Noto Sans KR', Arial, sans-serif",
            textColor: '#333333',
            bgColor: '#ffffff',
            readingMode: 'char',
            timerMinutes: 5,
            timerSeconds: 0,
            playbackMode: 'repeat'
        };

        // 요소들
        const fileInput = document.getElementById('fileInput');
        const librarySelect = document.getElementById('librarySelect');
        const newLibraryName = document.getElementById('newLibraryName');
        const newLibraryText = document.getElementById('newLibraryText');
        const playbackMode = document.getElementById('playbackMode');
        const startSpeedRange = document.getElementById('startSpeed');
        const startSpeedNum = document.getElementById('startSpeedNum');
        const endSpeedRange = document.getElementById('endSpeed');
        const endSpeedNum = document.getElementById('endSpeedNum');
        const transitionRange = document.getElementById('transitionDuration');
        const transitionNum = document.getElementById('transitionDurationNum');
        const fontFamily = document.getElementById('fontFamily');
        const fontSizeRange = document.getElementById('fontSize');
        const fontSizeNum = document.getElementById('fontSizeNum');
        const textColor = document.getElementById('textColor');
        const bgColor = document.getElementById('bgColor');
        const readingMode = document.getElementById('readingMode');
        const timerMinutes = document.getElementById('timerMinutes');
        const timerSeconds = document.getElementById('timerSeconds');
        const currentChar = document.getElementById('currentChar');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progressLabel = document.getElementById('progressLabel');
        const currentSpeedDisplay = document.getElementById('currentSpeed');
        const elapsed = document.getElementById('elapsed');
        const timerDisplay = document.getElementById('timerDisplay');
        const readingArea = document.getElementById('readingArea');
        const controls = document.getElementById('controls');
        const focusControls = document.getElementById('focusControls');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const focusResumeBtn = document.getElementById('focusResumeBtn');
        const focusPauseBtn = document.getElementById('focusPauseBtn');
        const focusStopBtn = document.getElementById('focusStopBtn');

        // 이벤트 리스너
        fileInput.addEventListener('change', handleFileSelect);
        
        // 타이머 업데이트
        timerMinutes.addEventListener('input', () => {
            settings.timerMinutes = parseInt(timerMinutes.value) || 0;
            updateTimerDisplay();
        });
        timerSeconds.addEventListener('input', () => {
            settings.timerSeconds = parseInt(timerSeconds.value) || 0;
            updateTimerDisplay();
        });
        
        // 속도 동기화
        startSpeedRange.addEventListener('input', () => {
            startSpeedNum.value = startSpeedRange.value;
            settings.startSpeed = parseInt(startSpeedRange.value);
        });
        startSpeedNum.addEventListener('input', () => {
            startSpeedRange.value = startSpeedNum.value;
            settings.startSpeed = parseInt(startSpeedNum.value);
        });
        endSpeedRange.addEventListener('input', () => {
            endSpeedNum.value = endSpeedRange.value;
            settings.endSpeed = parseInt(endSpeedRange.value);
        });
        endSpeedNum.addEventListener('input', () => {
            endSpeedRange.value = endSpeedNum.value;
            settings.endSpeed = parseInt(endSpeedNum.value);
        });
        transitionRange.addEventListener('input', () => {
            transitionNum.value = transitionRange.value;
            settings.transitionDuration = parseInt(transitionRange.value);
        });
        transitionNum.addEventListener('input', () => {
            transitionRange.value = transitionNum.value;
            settings.transitionDuration = parseInt(transitionNum.value);
        });
        fontSizeRange.addEventListener('input', () => {
            fontSizeNum.value = fontSizeRange.value;
            settings.fontSize = parseInt(fontSizeRange.value);
            updateFontSize();
        });
        fontSizeNum.addEventListener('input', () => {
            fontSizeRange.value = fontSizeNum.value;
            settings.fontSize = parseInt(fontSizeNum.value);
            updateFontSize();
        });

        // 스타일 변경 이벤트
        fontFamily.addEventListener('change', () => {
            settings.fontFamily = fontFamily.value;
            updateFontFamily();
        });
        textColor.addEventListener('change', () => {
            settings.textColor = textColor.value;
            updateTextColor();
        });
        bgColor.addEventListener('change', () => {
            settings.bgColor = bgColor.value;
            updateBgColor();
        });
        readingMode.addEventListener('change', () => {
            settings.readingMode = readingMode.value;
            if (text) {
                processedText = processText(text);
                currentChar.textContent = `텍스트가 재처리되었습니다. (${processedText.length}${readingMode.value === 'word' ? '단어' : '자'}) 시작 버튼을 눌러주세요.`;
                resetProgress();
            }
        });

        playbackMode.addEventListener('change', () => {
            settings.playbackMode = playbackMode.value;
        });

        // 키보드 이벤트
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (isReading && !isPaused) {
                    pauseReading();
                } else if (isPaused) {
                    resumeReading();
                } else if (text) {
                    startReading();
                }
            } else if (e.code === 'Escape') {
                if (isReading) {
                    stopReading();
                }
                if (isFocusMode) {
                    exitFocusMode();
                }
            }
        });

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type === 'text/plain') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const rawText = e.target.result;
                    loadText(rawText, file.name);
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        function loadText(rawText, filename = '') {
            text = rawText;
            lastLoadedText = { content: rawText, name: filename };
            processedText = processText(rawText);
            currentChar.textContent = `텍스트가 로드되었습니다. (${processedText.length}자) 시작 버튼을 눌러주세요.`;
            resetProgress();
        }

        function processText(rawText) {
            const mode = readingMode.value;
            if (mode === 'word') {
                // 단어 모드: 여러 공백을 하나로 통합하고 split
                return rawText.replace(/\s+/g, ' ').trim().split(' ').filter(word => word.length > 0);
            } else {
                // 글자 모드: 모든 공백 문자 제거
                return rawText.replace(/\s/g, '').split('').filter(char => char.length > 0);
            }
        }

        function populateLibrary() {
            librarySelect.innerHTML = '<option value="">라이브러리에서 선택...</option>';
            textLibrary.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${item.name} (${item.content.length}자)`;
                librarySelect.appendChild(option);
            });
        }

        function loadFromLibrary() {
            const selectedIndex = librarySelect.value;
            if (selectedIndex !== '') {
                const selectedItem = textLibrary[selectedIndex];
                loadText(selectedItem.content, selectedItem.name);
            }
        }

        function addTextToLibrary() {
            const name = newLibraryName.value.trim();
            const content = newLibraryText.value.trim();
            
            if (!name) {
                alert('텍스트 이름을 입력해주세요.');
                return;
            }
            if (!content) {
                alert('텍스트 내용을 입력해주세요.');
                return;
            }
            
            textLibrary.push({
                name: name,
                content: content
            });
            
            populateLibrary();
            saveLibraryToStorage();
            newLibraryName.value = '';
            newLibraryText.value = '';
            alert(`"${name}"이(가) 라이브러리에 추가되었습니다.`);
        }

        function addCurrentToLibrary() {
            const name = newLibraryName.value.trim();
            if (!name) {
                alert('라이브러리 항목 이름을 입력해주세요.');
                return;
            }
            if (!text) {
                alert('추가할 텍스트가 없습니다. 먼저 텍스트를 로드해주세요.');
                return;
            }
            
            textLibrary.push({
                name: name,
                content: text
            });
            
            populateLibrary();
            saveLibraryToStorage();
            newLibraryName.value = '';
            alert(`"${name}"이(가) 라이브러리에 추가되었습니다.`);
        }

        function deleteFromLibrary() {
            const selectedIndex = librarySelect.value;
            if (selectedIndex === '') {
                alert('삭제할 항목을 선택해주세요.');
                return;
            }
            
            const selectedItem = textLibrary[selectedIndex];
            if (confirm(`"${selectedItem.name}"을(를) 삭제하시겠습니까?`)) {
                textLibrary.splice(selectedIndex, 1);
                populateLibrary();
                saveLibraryToStorage();
                alert('삭제되었습니다.');
            }
        }

        function loadRandomText() {
            if (textLibrary.length <= 1) return;
            
            // 현재 텍스트와 다른 것 중에서 랜덤 선택
            const availableTexts = textLibrary.filter(item => item.content !== text);
            if (availableTexts.length === 0) return;
            
            const randomIndex = Math.floor(Math.random() * availableTexts.length);
            const randomText = availableTexts[randomIndex];
            
            // 새 텍스트로 변경하되 인덱스는 리셋
            text = randomText.content;
            processedText = processText(randomText.content);
            currentIndex = 0;
            textRepeatCount++;
            
            // 사용자에게 알림 (집중 모드에서는 보이지 않음)
            console.log(`🎲 랜덤 선택: ${randomText.name}`);
        }

        function saveLibraryToStorage() {
            // 메모리에만 저장 (Claude.ai 환경에서는 localStorage 지원 안함)
            // 자신의 환경에서 사용하려면 아래 주석을 해제하세요:
            // try {
            //     localStorage.setItem('speedReadingLibrary', JSON.stringify(textLibrary));
            // } catch (e) {
            //     console.log('로컬 저장소 저장 실패:', e);
            // }
        }

        function loadLibraryFromStorage() {
            // 메모리에서만 로드 (Claude.ai 환경에서는 localStorage 지원 안함)
            // 자신의 환경에서 사용하려면 아래 주석을 해제하세요:
            // try {
            //     const saved = localStorage.getItem('speedReadingLibrary');
            //     if (saved) {
            //         const savedLibrary = JSON.parse(saved);
            //         textLibrary = [...textLibrary, ...savedLibrary];
            //     }
            // } catch (e) {
            //     console.log('로컬 저장소 로드 실패:', e);
            // }
        }

        function loadSampleText() {
            // 샘플 텍스트는 이제 라이브러리의 첫 번째 항목으로 처리
            if (textLibrary.length > 0) {
                loadText(textLibrary[0].content, textLibrary[0].name);
            }
        }

        function startReading() {
            if (!text) {
                alert('먼저 텍스트를 선택해주세요.');
                return;
            }

            // 현재 읽기 모드에 맞게 텍스트 재처리
            processedText = processText(text);

            isReading = true;
            isPaused = false;
            startTime = performance.now(); // 더 정확한 시간 측정
            textRepeatCount = 0;
            currentIndex = 0;
            nextScheduledTime = startTime;
            
            // 타이머 설정
            totalTimerMs = (settings.timerMinutes * 60 + settings.timerSeconds) * 1000;
            remainingTimerMs = totalTimerMs;
            
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;

            // 집중 모드 버튼 상태 업데이트
            updateFocusButtons();

            if (totalTimerMs > 0) {
                startTimer();
                progressLabel.textContent = '훈련 시간';
            } else {
                progressLabel.textContent = '텍스트 진행률';
            }

            enterFocusMode();
            
            // 성능 최적화된 디스플레이 시작
            scheduleNextItem();
        }

        function pauseReading() {
            isPaused = true;
            if (currentTimeout) {
                clearTimeout(currentTimeout);
            }
            if (frameRequestId) {
                cancelAnimationFrame(frameRequestId);
                frameRequestId = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            startBtn.textContent = '▶️ 재개';
            
            updateFocusButtons();
        }

        function resumeReading() {
            if (!isReading) {
                startReading();
                return;
            }
            
            isPaused = false;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            startBtn.textContent = '▶️ 시작';
            
            // 타이머 재시작 시 정확한 시간 보정
            if (totalTimerMs > 0 && remainingTimerMs > 0) {
                startTimer();
            }
            
            updateFocusButtons();
            
            // 재개시 자동으로 집중 모드로 전환
            if (isFocusMode) {
                readingArea.classList.remove('show-controls');
                resetFocusTimeout();
            }
            
            // 정확한 시간 재설정
            nextScheduledTime = performance.now();
            scheduleNextItem();
        }

        function stopReading() {
            isReading = false;
            isPaused = false;
            if (currentTimeout) {
                clearTimeout(currentTimeout);
            }
            if (frameRequestId) {
                cancelAnimationFrame(frameRequestId);
                frameRequestId = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            startBtn.textContent = '▶️ 시작';
            
            exitFocusMode();
            resetProgress();
            updateFocusButtons();
            progressLabel.textContent = '진행률';
            currentChar.textContent = '훈련이 완료되었습니다. 다시 시작하려면 시작 버튼을 눌러주세요.';
        }

        function scheduleNextItem() {
            if (!isReading || isPaused) return;

            const now = performance.now();
            
            if (now >= nextScheduledTime) {
                displayCurrentItem();
                
                // 다음 아이템 스케줄링
                const currentSpeed = getCurrentSpeed();
                nextScheduledTime += currentSpeed;
                currentIndex++;
                
                // 즉시 다음 아이템 처리
                scheduleNextItem();
            } else {
                // 정확한 타이밍을 위해 requestAnimationFrame 사용
                frameRequestId = requestAnimationFrame(scheduleNextItem);
            }
        }

        function displayCurrentItem() {
            // 텍스트 끝 처리
            if (currentIndex >= processedText.length) {
                if (totalTimerMs > 0 && remainingTimerMs > 0) {
                    const mode = settings.playbackMode;
                    if (mode === 'random' && textLibrary.length > 1) {
                        loadRandomText();
                    } else {
                        currentIndex = 0;
                        textRepeatCount++;
                    }
                } else {
                    stopReading();
                    return;
                }
            }

            // 현재 아이템 표시 (DOM 업데이트 최소화)
            const currentItem = processedText[currentIndex];
            if (currentChar.textContent !== currentItem) {
                currentChar.textContent = currentItem;
            }

            // 10번째마다 한 번씩만 UI 업데이트 (성능 최적화)
            if (currentIndex % 10 === 0 || currentIndex === 0) {
                updateProgressDisplay();
            }
        }

        function updateProgressDisplay() {
            const now = performance.now();
            
            // 진행률 업데이트
            const totalItems = processedText.length;
            let displayProgress;
            
            if (totalTimerMs > 0) {
                const timerProgress = ((totalTimerMs - remainingTimerMs) / totalTimerMs) * 100;
                displayProgress = Math.min(100, Math.max(0, timerProgress));
            } else {
                const textProgress = ((textRepeatCount * totalItems + currentIndex) / totalItems) * 100;
                displayProgress = Math.min(100, textProgress);
            }
            
            // DOM 업데이트 최소화 - 실제 변화가 있을 때만
            const progressPercent = Math.round(displayProgress);
            if (progressText.textContent !== progressPercent + '%') {
                progressFill.style.width = displayProgress + '%';
                progressText.textContent = progressPercent + '%';
            }

            // 경과 시간 업데이트 (1초마다만)
            if (now - lastUpdateTime > 1000) {
                const elapsedMs = now - startTime;
                const minutes = Math.floor(elapsedMs / 60000);
                const seconds = Math.floor((elapsedMs % 60000) / 1000);
                const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (elapsed.textContent !== timeStr) {
                    elapsed.textContent = timeStr;
                }

                // 현재 속도 표시 업데이트
                const currentSpeed = Math.round(getCurrentSpeed());
                const speedStr = currentSpeed.toString();
                if (currentSpeedDisplay.textContent !== speedStr) {
                    currentSpeedDisplay.textContent = speedStr;
                }

                lastUpdateTime = now;
            }
        }

        function getCurrentSpeed() {
            const startSpeed = settings.startSpeed;
            const endSpeed = settings.endSpeed;
            const transitionDuration = settings.transitionDuration;

            if (transitionDuration === 0) {
                return startSpeed;
            }

            // 시간 기반으로 속도 계산 (더 정확한 performance.now() 사용)
            const elapsedSeconds = (performance.now() - startTime) / 1000;
            
            if (elapsedSeconds >= transitionDuration) {
                return endSpeed;
            }
            
            const progressRatio = elapsedSeconds / transitionDuration;
            const speedDiff = endSpeed - startSpeed;
            const currentSpeed = startSpeed + (speedDiff * progressRatio);
            
            return Math.max(endSpeed, Math.min(startSpeed, currentSpeed));
        }

        function enterFocusMode() {
            isFocusMode = true;
            readingArea.classList.add('focus-mode');
            controls.classList.add('hidden');
            readingArea.classList.remove('show-controls');
            resetFocusTimeout();
        }

        function exitFocusMode() {
            isFocusMode = false;
            readingArea.classList.remove('focus-mode');
            controls.classList.remove('hidden');
            readingArea.classList.remove('show-controls');
            if (focusTimeout) {
                clearTimeout(focusTimeout);
            }
        }

        function toggleFocusMode() {
            if (isReading) {
                if (isFocusMode) {
                    // 집중 모드 해제시 자동 일시정지
                    if (!isPaused) {
                        pauseReading();
                    }
                    readingArea.classList.add('show-controls');
                    updateFocusButtons();
                } else {
                    readingArea.classList.remove('show-controls');
                    enterFocusMode();
                }
            }
        }

        function resetFocusTimeout() {
            if (focusTimeout) {
                clearTimeout(focusTimeout);
            }
            if (isReading && !isFocusMode && !isPaused) {
                focusTimeout = setTimeout(() => {
                    if (isReading && !isPaused) {
                        enterFocusMode();
                    }
                }, 3000);
            }
        }

        function updateFocusButtons() {
            if (isPaused) {
                focusResumeBtn.style.display = 'block';
                focusPauseBtn.style.display = 'none';
            } else {
                focusResumeBtn.style.display = 'none';
                focusPauseBtn.style.display = 'block';
            }
        }

        function loadSettings() {
            // 설정값들을 UI에 적용
            startSpeedRange.value = settings.startSpeed;
            startSpeedNum.value = settings.startSpeed;
            endSpeedRange.value = settings.endSpeed;
            endSpeedNum.value = settings.endSpeed;
            transitionRange.value = settings.transitionDuration;
            transitionNum.value = settings.transitionDuration;
            fontSizeRange.value = settings.fontSize;
            fontSizeNum.value = settings.fontSize;
            fontFamily.value = settings.fontFamily;
            textColor.value = settings.textColor;
            bgColor.value = settings.bgColor;
            readingMode.value = settings.readingMode;
            timerMinutes.value = settings.timerMinutes;
            timerSeconds.value = settings.timerSeconds;
            playbackMode.value = settings.playbackMode;
        }

        function updateFontFamily() {
            currentChar.style.fontFamily = fontFamily.value;
        }

        function updateFontSize() {
            currentChar.style.fontSize = fontSizeNum.value + 'px';
        }

        function updateTextColor() {
            currentChar.style.color = textColor.value;
        }

        function updateBgColor() {
            readingArea.style.background = bgColor.value;
        }

        function resetProgress() {
            currentIndex = 0;
            textRepeatCount = 0;
            progressFill.style.width = '0%';
            progressText.textContent = '0%';
            progressLabel.textContent = '진행률';
            currentSpeedDisplay.textContent = settings.startSpeed;
            elapsed.textContent = '00:00';
            
            // 타이머 리셋
            totalTimerMs = (settings.timerMinutes * 60 + settings.timerSeconds) * 1000;
            remainingTimerMs = totalTimerMs;
            updateTimerDisplay();
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                remainingTimerMs -= 1000;
                updateTimerDisplay();
                
                if (remainingTimerMs <= 0) {
                    stopReading();
                    alert('⏰ 설정된 훈련 시간이 완료되었습니다!');
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            if (isReading && totalTimerMs > 0) {
                // 훈련 중일 때는 남은 시간 표시
                const remainingMinutes = Math.floor(remainingTimerMs / 60000);
                const remainingSeconds = Math.floor((remainingTimerMs % 60000) / 1000);
                timerDisplay.textContent = `${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                // 설정된 시간 표시
                timerDisplay.textContent = `${settings.timerMinutes.toString().padStart(2, '0')}:${settings.timerSeconds.toString().padStart(2, '0')}`;
            }
        }

        // 초기 스타일 적용
        loadLibraryFromStorage();
        loadSettings();
        updateFontFamily();
        updateFontSize();
        updateTextColor();
        updateBgColor();
        updateTimerDisplay();
        updateFocusButtons();
        populateLibrary();
        
        // 페이지 로드시 샘플 텍스트 자동 로딩
        if (textLibrary.length > 0) {
            loadText(textLibrary[0].content, textLibrary[0].name);
        }
    </script>
</body>
</html>
